//! Simple roughing toolpath generation.
//!
//! Generates zig-zag layer-by-layer face milling G-code from workpiece dimensions.
//! Not STL-aware â€” just removes material layer by layer.

/// Generate a roughing G-code program from workpiece dimensions.
///
/// # Parameters
/// - `x_extent`, `y_extent`: workpiece half-extents in mm
/// - `z_top`: top of workpiece in mm (G-code Z)
/// - `z_bottom`: bottom cut depth in mm (G-code Z)
/// - `step_down`: depth per layer in mm
/// - `step_over`: lateral step between passes in mm
/// - `feed_rate`: cutting feed rate in mm/min
/// - `rapid_height`: safe Z for rapid moves in mm
pub fn generate_roughing(
    x_extent: f64,
    y_extent: f64,
    z_top: f64,
    z_bottom: f64,
    step_down: f64,
    step_over: f64,
    feed_rate: f64,
    rapid_height: f64,
) -> String {
    let mut gcode = String::new();

    gcode.push_str("(Roughing toolpath - generated by SimuForge)\n");
    gcode.push_str(&format!("(Workpiece: {:.1}x{:.1}mm, Z {:.1} to {:.1})\n",
        x_extent * 2.0, y_extent * 2.0, z_top, z_bottom));
    gcode.push_str(&format!("(Step down: {:.1}mm, Step over: {:.1}mm)\n", step_down, step_over));
    gcode.push_str("\n");

    // Start position
    gcode.push_str(&format!("G0 Z{:.2}\n", rapid_height));
    gcode.push_str("M3 S10000\n");
    gcode.push_str("\n");

    let x_min = -x_extent;
    let x_max = x_extent;

    let mut z = z_top;
    while z > z_bottom {
        z = (z - step_down).max(z_bottom);

        gcode.push_str(&format!("(Layer Z={:.2})\n", z));

        // Zig-zag in Y direction
        let mut y = -y_extent;
        let mut forward = true;
        let mut first_pass = true;

        while y <= y_extent + 1e-6 {
            if first_pass {
                // Rapid to start of first pass
                gcode.push_str(&format!("G0 X{:.2} Y{:.2}\n", if forward { x_min } else { x_max }, y));
                gcode.push_str(&format!("G1 Z{:.2} F{:.0}\n", z, feed_rate * 0.5));
                first_pass = false;
            } else {
                // Rapid to start of new pass (step over)
                gcode.push_str(&format!("G0 Z{:.2}\n", z + 2.0)); // lift slightly
                gcode.push_str(&format!("G0 Y{:.2}\n", y));
                gcode.push_str(&format!("G1 Z{:.2} F{:.0}\n", z, feed_rate * 0.5));
            }

            // Cut across X
            if forward {
                gcode.push_str(&format!("G1 X{:.2} Y{:.2} F{:.0}\n", x_max, y, feed_rate));
            } else {
                gcode.push_str(&format!("G1 X{:.2} Y{:.2} F{:.0}\n", x_min, y, feed_rate));
            }

            forward = !forward;
            y += step_over;
        }

        // Retract between layers
        gcode.push_str(&format!("G0 Z{:.2}\n", rapid_height));
        gcode.push_str("\n");
    }

    gcode.push_str("M5\n");
    gcode.push_str(&format!("G0 Z{:.2}\n", rapid_height));
    gcode.push_str("G0 X0 Y0\n");
    gcode.push_str("(End of roughing)\n");

    gcode
}

/// Generate a simple pocket milling toolpath (single depth, zig-zag).
pub fn generate_pocket(
    x_min: f64,
    x_max: f64,
    y_min: f64,
    y_max: f64,
    z_depth: f64,
    step_over: f64,
    feed_rate: f64,
    rapid_height: f64,
) -> String {
    let mut gcode = String::new();

    gcode.push_str("(Pocket toolpath - generated by SimuForge)\n");
    gcode.push_str(&format!("G0 Z{:.2}\n", rapid_height));
    gcode.push_str("M3 S10000\n");

    // Rapid to start
    gcode.push_str(&format!("G0 X{:.2} Y{:.2}\n", x_min, y_min));
    gcode.push_str(&format!("G1 Z{:.2} F{:.0}\n", z_depth, feed_rate * 0.5));

    let mut y = y_min;
    let mut forward = true;

    while y <= y_max + 1e-6 {
        if forward {
            gcode.push_str(&format!("G1 X{:.2} Y{:.2} F{:.0}\n", x_max, y, feed_rate));
        } else {
            gcode.push_str(&format!("G1 X{:.2} Y{:.2} F{:.0}\n", x_min, y, feed_rate));
        }

        if y + step_over <= y_max + 1e-6 {
            y += step_over;
            // Step over
            gcode.push_str(&format!("G1 Y{:.2} F{:.0}\n", y, feed_rate));
        } else {
            break;
        }
        forward = !forward;
    }

    gcode.push_str(&format!("G0 Z{:.2}\n", rapid_height));
    gcode.push_str("M5\n");
    gcode.push_str("G0 X0 Y0\n");

    gcode
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_roughing() {
        let gcode = generate_roughing(
            50.0, 50.0,   // 100x100mm workpiece
            0.0, -5.0,    // cut 5mm deep
            2.5,          // 2.5mm step down
            4.0,          // 4mm step over
            600.0,        // 600 mm/min
            10.0,         // 10mm rapid height
        );
        assert!(gcode.contains("G0"));
        assert!(gcode.contains("G1"));
        assert!(gcode.contains("M3"));
        assert!(gcode.contains("M5"));
        // Should have at least 2 layers (5mm / 2.5mm)
        assert!(gcode.matches("Layer").count() >= 2);
    }

    #[test]
    fn test_generate_pocket() {
        let gcode = generate_pocket(
            -25.0, 25.0,  // X range
            -25.0, 25.0,  // Y range
            -3.0,         // 3mm deep
            4.0,          // 4mm step over
            600.0,        // feed rate
            10.0,         // rapid height
        );
        assert!(gcode.contains("G1"));
        assert!(gcode.contains("M3"));
    }
}
